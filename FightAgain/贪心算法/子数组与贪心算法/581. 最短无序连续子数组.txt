# 题目



# 思路

思路1

排序后比较

思路2

我们可以假设把这个数组分成三段，左段和右段是标准的升序数组，中段数组虽是无序的，但满足最小值大于左段的最大值，最大值小于右段的最小值。


那么我们目标就很明确了，找中段的左右边界，我们分别定义为begin 和 end;
分两头开始遍历:

从左到右维护一个最大值max,在进入右段之前，那么遍历到的nums[i]都是小于max的，我们要求的end就是遍历中最后一个小于max元素的位置；
同理，从右到左维护一个最小值min，在进入左段之前，那么遍历到的nums[i]也都是大于min的，要求的begin也就是最后一个大于min元素的位置。

详情见https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/si-lu-qing-xi-ming-liao-kan-bu-dong-bu-cun-zai-de-/


# 代码

思路1

class Solution(object):
    def findUnsortedSubarray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        tmp = [x for x in nums]
        nums.sort()
        if nums == tmp:
            return 0
        left, right = 0, len(nums)-1
        while left <= len(nums)-1:
            if nums[left] != tmp[left]:
                break
            left += 1
        while right >= 0:
            if nums[right] != tmp[right]:
                break
            right -= 1
        
        return right - left + 1

注意：end的初始化为-1，是为了处理原序列已经是升序。


