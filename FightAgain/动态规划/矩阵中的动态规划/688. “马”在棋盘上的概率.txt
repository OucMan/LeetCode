# 题目

已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。 

现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。 

国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。

现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。

求移动结束后，“马” 仍留在棋盘上的概率。

示例：

输入: 3, 2, 0, 0
输出: 0.0625
解释: 
输入的数据依次为 N, K, r, c
第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。
所以 “马” 在结束后仍在棋盘上的概率为 0.0625。
 

注意：

N 的取值范围为 [1, 25]
K 的取值范围为 [0, 100]
开始时，“马” 总是位于棋盘上


# 思路

动态规划

dp[k][i][j]表示移动k次时，马出现在位置[i,j]的次数，初始化dp[0][r][c] = 1

转移函数
dp[k][当前行][当前列] += dp[k-1][前一位置行][前一位置列] 

最后查看当移动K步后，棋盘上马出现的次数和，就是经历K步之后马还在棋盘上的总数。

# 代码

class Solution(object):
    def knightProbability(self, N, K, r, c):
        """
        :type N: int
        :type K: int
        :type r: int
        :type c: int
        :rtype: float
        """
        dp = [[[0] * N for _ in range(N)] for _ in range(K+1)]
        dp[0][r][c] = 1
        
        for k in range(1, K+1):
            for i in range(N):
                for j in range(N):
                    for x, y in [(-1,-2),(-2,-1),(-2,1),(-1,2),(2,1),(1,2),(2,-1),(1,-2)]:
                        ni, nj = i + x, j + y
                        if 0 <= ni < N and 0 <= nj < N:
                            dp[k][ni][nj] += dp[k-1][i][j]
        res = 0
        for i in range(N):
            for j in range(N):
                res += dp[K][i][j]

        return res * 1.0 / 8 ** K
        
        
