#################题目描述####################

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1：

输入:
26

输出:
"1a"
示例 2：

输入:
-1

输出:
"ffffffff"

##############思路################

数字在计算机中都是以二进制表示的，int为4个字节，共有32位，4位二进制数可以表示为一个十六进制的数，所以将输入数字四位四位的转换，每四位转换成一个数。将输入数字和0x1111做与运算则得到最低四位，再将输入数字右移四位，和0x1111做与运算，直到32位全部转换
另外，输出时不能包含前面多余的零，在输出时要从第一个不为0的数起开始输出，Python lstrip() 方法用于截掉字符串左边的空格或指定字符。

对于负数来说，在计算机中，负数以原码的补码表示：负数的原码是绝对值再设最高位符号位为1，比如-5：
10000000 00000000 00000000 00000101 原码
111111111 111111111 111111111 111111010 反码：除符号位其余全取反
111111111 111111111 111111111 111111011 补码：反码+1

################代码##################

class Solution(object):
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0:
            return '0'
        tmp = 0xf
        digits = '0123456789abcdef'
        result = ''
        for i in range(8):
            result = digits[num & tmp] + result
            num = num >> 4
        return result.lstrip('0')
