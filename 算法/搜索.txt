



77. 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

代码：
class Solution(object):
    def combine(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
        if n<1 or k>n:
            return []
        res = []
        self.dps(range(1,n+1), k, res, [])
        return res
    def dps(self, array, k, res, path):
        if k>len(array):
            return 
        if k==0:
            res.append(path)
        for i in range(len(array)):
            self.dps(array[i+1:], k-1, res, path+[array[i]])


39.给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
示例 2:

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

代码：

class Solution(object):
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        if not candidates:
            return []
        if min(candidates) > target:
            return []
        res = []
        self.dps(candidates, target, res, [])
        return res
    
    def dps(self, array, target, res, path):
        if target == 0:
            path.sort()
            if path not in res:
                res.append(path)
        elif min(array) > target:
            return
        for i in range(len(array)):
            if array[i] > target:
                continue
            self.dps(array, target-array[i], res, path + [array[i]])

            
